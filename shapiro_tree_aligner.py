'''
Specific AligjnmentRules for shapiro values in the tree alignments
'''

import shapiro_generator
import tree_aligner
import IUPAC

import logging
import sys

'''
SEQ_PARAMS = {'match_score': 100, 'delete_penalty': 0, 'insert_penalty': 0, 'mismatch_penalty': 0,
              'panelty_del_N': 0, 'match_score_N': 0.1}
'''
SEQ_PARAMS = {'match_score': 0, 'delete_penalty': -1000, 'insert_penalty': -1, 'mismatch_penalty': -1000,
              'panelty_del_N': -1, 'match_score_N': 0}


def align_single_seq(seq_one, seq_two):
    alignment_matrix = IUPAC.align_iupac_dna_sequence(seq_one, seq_two, **SEQ_PARAMS)
    return IUPAC.get_best_score(alignment_matrix), \
           IUPAC.generate_optimal_alignments(seq_one, seq_two, return_single=True,
                                             score_matrix=alignment_matrix, **SEQ_PARAMS)


# aligns list of sequences. list is generated by splitting the sequences whenever a '.' is found
def align_sequences(sequence_one, sequence_two):
    def retrace(score_matrix, transition_matrix):
        alignment_list = []
        one_index = len(score_matrix) - 1
        two_index = len(score_matrix[0]) - 1
        while one_index > 0 or two_index > 0:
            transition_pair = transition_matrix[one_index][two_index]
            # match
            if one_index > 0 and two_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index - 1][two_index - 1] + transition_pair[0]:
                one_index -= 1
                two_index -= 1
            # insert
            elif one_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index - 1][two_index] + transition_pair[0]:
                one_index -= 1
            # delete
            elif two_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index][two_index - 1] + transition_pair[0]:
                two_index -= 1
            else:
                raise IUPAC.IUPACAlignmentError("Score matrix, no match!\n{}[{}][{}] {}"
                                                .format(score_matrix, one_index, two_index, transition_pair[0]))
            alignment_list.append(transition_pair[1])
        return alignment_list

    seqs_one = sequence_one.split('.')
    seqs_two = sequence_two.split('.')
    score_matrix = [([0] * (len(seqs_two) + 1)) for i in range(0, len(seqs_one) + 1)]
    transition_matrix = [([0] * (len(seqs_two) + 1)) for i in range(0, len(seqs_one) + 1)]
    for one_index in range(0, len(seqs_one) + 1):
        for two_index in range(0, len(seqs_two) + 1):
            if one_index == 0 and two_index == 0:
                continue
            transition_list = []
            score_list = []
            # match
            if one_index > 0 and two_index > 0:
                calc_score, alignment = align_single_seq(seqs_one[one_index - 1], seqs_two[two_index - 1])
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index - 1][two_index - 1])
            # insert
            if one_index > 0:
                calc_score, alignment = align_single_seq(seqs_one[one_index - 1], '')
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index - 1][two_index])
            # delete
            if two_index > 0:
                calc_score, alignment = align_single_seq('', seqs_two[two_index - 1])
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index][two_index - 1])
            max_value = max(score_list)
            transition_matrix[one_index][two_index] = transition_list[score_list.index(max_value)]
            score_matrix[one_index][two_index] = max_value
    return score_matrix[one_index][two_index], retrace(score_matrix, transition_matrix)


def cmp_shapiro_tree_values(value_one, value_two):
    result = None
    alignment = []
    value_one_name = value_one.name
    value_two_name = value_two.name
    if value_one_name[0] == value_two_name[0] or \
            ((value_one_name[0] == 'M' or value_one_name[0] == 'I' or value_one_name[0] == 'B' or value_one_name[
                0] == 'H') and
             (value_two_name[0] == 'M' or value_two_name[0] == 'I' or value_two_name[0] == 'B' or value_two_name[
                 0] == 'H')):
        score, alignment = align_sequences(value_one.sequence, value_two.sequence)
        result = score
    logging.debug("matched {} - {}, score {} alignment {}".format(value_one, value_two, result, alignment))
    return result  # , alignment


def merge_shapiro_tree_values(value_one, value_two):
    return value_one


# actually merge string and length etc...
def smart_merge_shapiro_tree_values(value_one, value_two):
    raise NotImplementedError


def insert_shapiro_func(value):
    score, _ = align_sequences(value.sequence, '')
    logging.debug("insert {} score {}".format(value, score))
    return score


def delete_shapiro_func(value, is_target=False):
    if is_target:
        score, _ = align_sequences('', value.sequence)
    else:
        score, _ = align_sequences(value.sequence, '')
    logging.debug("delete {} {} score {}".format(value, '(Target)' if is_target else '', score))
    return score


# recursively turn a shapiro string into a tree
def shapiro_to_tree(shapiro_str, shapiro_index, sequence):
    bracket_stack = []
    str_index = len(shapiro_str) - 1
    bp_index = len(shapiro_index) - 1
    # empty string or not proper string (must start with bracket
    if str_index < 0 or shapiro_str[str_index] != ')':
        if str_index >= 0:
            logging.error("Shapiro does not end with close bracket: {}".format(shapiro_str))
        return None
    # get value of top tree
    bracket_count = 1
    str_index -= 1
    bp_index -= 1
    current_value = ""
    current_bp_list = ""
    while shapiro_str[str_index] != ')' and shapiro_str[str_index] != '(':
        current_value = shapiro_str[str_index] + current_value
        str_index -= 1
    while shapiro_index[bp_index] != ')' and shapiro_index[bp_index] != '(':
        current_bp_list = shapiro_index[bp_index] + current_bp_list
        bp_index -= 1
    res_tree = tree_aligner.Tree(ShapiroTreeValue(current_value, current_bp_list, sequence), [])
    if shapiro_str[str_index] == '(':
        bracket_count -= 1
    # split sub groups and recursively send them forward
    str_start_index = str_index
    bp_start_index = bp_index
    while bracket_count > 0:
        if shapiro_str[str_index] == ')':
            bracket_count += 1
            while shapiro_index[bp_index] != ')':
                bp_index -= 1
        elif shapiro_str[str_index] == '(':
            bracket_count -= 1
            while shapiro_index[bp_index] != '(':
                bp_index -= 1
        if bracket_count == 1:
            res_tree.add_child(shapiro_to_tree(shapiro_str[str_index:str_start_index + 1],
                                               shapiro_index[bp_index:bp_start_index + 1], sequence))
            str_start_index = str_index - 1
            bp_start_index = bp_index - 1
        str_index -= 1
        bp_index -= 1
    return res_tree


class ShapiroTreeValue:
    def __init__(self, shapiro_str_name, shapiro_index, sequence):
        self.name = shapiro_str_name[0]
        try:
            self.size = (int(shapiro_str_name[1:]) if shapiro_str_name[1:] != '' else 0)
        except ValueError:
            self.size = 0
            logging.error(
                "ShapiroTreeValue.__init__ error parsing ShapiroTreeValue({}, {}, {})".format(shapiro_str_name,
                                                                                              shapiro_index, sequence))
        if self.size == 0:
            self.index_list = []
            self.sequence = ''
        else:
            self.index_list = []
            for index in shapiro_index[1:len(shapiro_index) - 1].split(','):
                index = index.strip()
                if index.isdigit():
                    self.index_list.append(int(index))
                else:
                    logging.error("Error decyphering shapiro: name={}, index={}, sequence={}".format(shapiro_str_name,
                                                                                                     shapiro_index,
                                                                                                     sequence))
            self.index_list.sort()
            indexes = []
            last = None
            current = []
            for index in self.index_list:
                if last is None or index == last + 1:
                    current.append(index)
                else:
                    indexes.append(current)
                    current = [index]
                last = index
            indexes.append(current)
            self.sequence = ".".join(["".join([sequence[index] for index in group]) for group in indexes])

    def __str__(self):
        return "{}{}({})".format(self.name, self.size, self.sequence)

    '''
    def __init__(self, name, size, index_list):
        self.name = name
        self.size = size
        self.index_list = index_list
    '''


def get_tree(structure, sequence):
    shapiro = shapiro_generator.get_shapiro(structure)
    return shapiro_to_tree(shapiro.shapiro, shapiro.shapiro_indexes, sequence)


def align_trees(tree_source, tree_target,
                alignment_rules=tree_aligner.AlignmentRules(insert_func=insert_shapiro_func,
                                                            delete_func=delete_shapiro_func,
                                                            cmp_func=cmp_shapiro_tree_values,
                                                            merge_func=merge_shapiro_tree_values)):
    return tree_aligner.align_trees(tree_source, tree_target, alignment_rules)


def align_shapiro(shapiro_source, sequence_source, shapiro_target, sequence_target,
                  alignment_rules=tree_aligner.AlignmentRules(insert_func=insert_shapiro_func,
                                                              delete_func=delete_shapiro_func,
                                                              cmp_func=cmp_shapiro_tree_values,
                                                              merge_func=merge_shapiro_tree_values)):
    tree_source = shapiro_to_tree(sequence_source.shapiro, shapiro_source.shapiro_indexesm, sequence_source)
    tree_target = shapiro_to_tree(shapiro_target.shapiro, shapiro_target.shapiro_indexesm, sequence_target)
    return tree_aligner.align_trees(tree_source, tree_target, alignment_rules)


if __name__ == "__main__":
    '''
    logging.basicConfig(level=logging.DEBUG)

    print('Simple test 1')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..((((((.......))))....))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((..((.(((.......))))))..))..))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGCUCUCGUAUAGGCUCGGCCCC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNUNNNNNNUYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    '''
    '''
    logging.basicConfig(level=logging.DEBUG)

    print('Simple test 2')
    shapiro_one = shapiro_generator.get_shapiro("((.(((...)))...(((((.......))))....))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((..((.(((.......))))))..))..))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGCUCUCGUAUAGGCUCGGCCCC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNUNNNNNNUYNNNNNNNN')
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    '''
    print('Test alignment distance 28 / 10')
    shapiro_one = shapiro_generator.get_shapiro("((((((((.(.(((((...((((((..((((.....)))))).))))....))))).)...))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'GCGGGUUAUGUGCUGAGAUAGGCCCUUGCAGCGUUAUUGUGGAGUUUCCCAUUAGCUCCCCUGACCCGC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    
    print('Test alignment distance 14 / 4')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..(.(.((((.((.....))...)))).).).((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'UCGGGAUAUGGUGGAAGGAUGAUGGCCAAGACCUUGCUCGCUGGGCUUCGGAUGCCCAGGUUGUUCCGA')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    print('Test alignment distance 1 / 0')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..((.(((((.......))))).)).......((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGUUAUCUCUAAGCUCUCGUAUAUGAUCCGGUUCUACACGCCGGAACGGCCCCAG')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    print('Test perfect alignment')
    shapiro_one = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(insert_func=insert_shapiro_func, delete_func=delete_shapiro_func,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}".format(aligned_score, aligned_tree))


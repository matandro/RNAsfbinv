'''
Specific AligjnmentRules for shapiro values in the tree alignments
'''

from rnafbinv import shapiro_generator, tree_aligner, IUPAC
import logging


def del_align_lower(s1, i1, s2, i2):
    if s2[i2] == 'N':
        return 1
    elif s2[i2] == 'n':
        if 0 < i2 < len(s2) - 1 and s2[i2 - 1] > 'Z' and s2[i2 + 1] > 'Z':
            return 20
    else:
        return 1000


def ins_align_lower(s1, i1, s2, i2):
    if 0 < i2 < len(s2) - 1 and s2[i2 - 1] > 'Z' and s2[i2] > 'Z':
        return 20
    else:
        return 1


DEFAULT_ALIGNMENT_SCORE = IUPAC.SequenceAlignmentScore(
    minmax_func=min,
    match_func=lambda s1, i1, s2, i2: IUPAC.agree(s1[i1], s2[i2], 0, 0, 1000),
    delete_func=del_align_lower,
    insert_func=ins_align_lower)


def align_single_seq(seq_one: str, seq_two: str):
    alignment_matrix = IUPAC.align_iupac_dna_sequence(seq_one, seq_two,
                                                      sequence_alignment_score=DEFAULT_ALIGNMENT_SCORE)
    best_score = IUPAC.get_best_score(alignment_matrix)
    best_alignment = IUPAC.generate_optimal_alignments(seq_one, seq_two, return_single=True,
                                                       score_matrix=alignment_matrix,
                                                       sequence_alignment_score=DEFAULT_ALIGNMENT_SCORE)
    # We generate single optimal alignment
    best_alignment = best_alignment[0]
    #logging.debug("Aligning '{}' to '{}' (Score: {})\nresult: {}".format(seq_one, seq_two, best_score, best_alignment))
    return best_score, best_alignment


# aligns list of sequences. list is generated by splitting the sequences whenever a '.' is found
def align_sequences(sequence_one: str, sequence_two: str):
    def retrace(score_matrix, transition_matrix):
        alignment_list = []
        one_index = len(score_matrix) - 1
        two_index = len(score_matrix[0]) - 1
        while one_index > 0 or two_index > 0:
            transition_pair = transition_matrix[one_index][two_index]
            # match
            if one_index > 0 and two_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index - 1][two_index - 1] + transition_pair[0]:
                one_index -= 1
                two_index -= 1
            # insert
            elif one_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index - 1][two_index] + transition_pair[0]:
                one_index -= 1
            # delete
            elif two_index > 0 and score_matrix[one_index][two_index] == \
                    score_matrix[one_index][two_index - 1] + transition_pair[0]:
                two_index -= 1
            else:
                raise IUPAC.IUPACAlignmentError("Score matrix, no match!\n{}[{}][{}] {}"
                                                .format(score_matrix, one_index, two_index, transition_pair[0]))
            alignment_list.append(transition_pair[1])
        return alignment_list

    seqs_one = sequence_one.split('.')
    seqs_two = sequence_two.split('.')
    score_matrix = [([0] * (len(seqs_two) + 1)) for i in range(0, len(seqs_one) + 1)]
    transition_matrix = [([0] * (len(seqs_two) + 1)) for i in range(0, len(seqs_one) + 1)]
    for one_index in range(0, len(seqs_one) + 1):
        for two_index in range(0, len(seqs_two) + 1):
            if one_index == 0 and two_index == 0:
                continue
            transition_list = []
            score_list = []
            # match
            if one_index > 0 and two_index > 0:
                calc_score, alignment = align_single_seq(seqs_one[one_index - 1], seqs_two[two_index - 1])
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index - 1][two_index - 1])
            # insert
            if one_index > 0:
                calc_score, alignment = align_single_seq(seqs_one[one_index - 1], '')
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index - 1][two_index])
            # delete
            if two_index > 0:
                calc_score, alignment = align_single_seq('', seqs_two[two_index - 1])
                transition_list.append((calc_score, alignment))
                score_list.append(calc_score + score_matrix[one_index][two_index - 1])
            max_value = min(score_list)
            transition_matrix[one_index][two_index] = transition_list[score_list.index(max_value)]
            score_matrix[one_index][two_index] = max_value
    return score_matrix[one_index][two_index], retrace(score_matrix, transition_matrix)


REDUCED_MOTIFS = 'BI'
LOOP_MOTIFS = 'HM' + REDUCED_MOTIFS


def cmp_shapiro_tree_values(value_one, value_two):
    result = None
    alignment = []
    if (value_two.preserve and value_one.name == value_two.name and value_one.size == value_two.size) or \
            (not value_two.preserve and (value_one.name == value_two.name or
                                         (value_one.name in LOOP_MOTIFS and value_two.name in LOOP_MOTIFS))):
        score, alignment = align_sequences(value_one.sequence, value_two.sequence)
        result = score
    logging.debug("{}matched {} - {}, score {} alignment {}".format('====PRESERVE====' if value_two.preserve else '',
                                                                    value_one, value_two, result, alignment))
    return result, alignment


def merge_shapiro_tree_values(value_one, value_two):
    return value_one


def delete_shapiro_func(value, is_target=False, reduced_min_bi=0):
    if is_target:
        score, align = align_sequences('', value.sequence)
        if value.preserve:
            score += 1000
        elif not (value.name in REDUCED_MOTIFS and value.size <= reduced_min_bi):
            score += 100
    else:
        score, align = align_sequences(value.sequence, '')
        if not (value.name in REDUCED_MOTIFS and value.size <= reduced_min_bi):
            score += 100
    logging.debug("{}delete {} {} score {}".format('====PRESERVE====' if value.preserve and is_target else '',
                  value, '(Target)' if is_target else '', score))
    return score, align


# recursively turn a shapiro string into a tree
def shapiro_to_tree(shapiro_str, shapiro_index, sequence):
    str_index = len(shapiro_str) - 1
    bp_index = len(shapiro_index) - 1
    # empty string or not proper string (must start with bracket
    if str_index < 0 or shapiro_str[str_index] != ')':
        if str_index >= 0:
            logging.error("Shapiro does not end with close bracket: {}".format(shapiro_str))
        return None
    # get value of top tree
    bracket_count = 1
    str_index -= 1
    bp_index -= 1
    current_value = ""
    current_bp_list = ""
    while shapiro_str[str_index] != ')' and shapiro_str[str_index] != '(':
        current_value = shapiro_str[str_index] + current_value
        str_index -= 1
    while shapiro_index[bp_index] != ')' and shapiro_index[bp_index] != '(':
        current_bp_list = shapiro_index[bp_index] + current_bp_list
        bp_index -= 1
    res_tree = tree_aligner.Tree(ShapiroTreeValue(current_value, current_bp_list, sequence), [])
    if shapiro_str[str_index] == '(':
        bracket_count -= 1
    # split sub groups and recursively send them forward
    str_start_index = str_index
    bp_start_index = bp_index
    while bracket_count > 0:
        if shapiro_str[str_index] == ')':
            bracket_count += 1
            while shapiro_index[bp_index] != ')':
                bp_index -= 1
        elif shapiro_str[str_index] == '(':
            bracket_count -= 1
            while shapiro_index[bp_index] != '(':
                bp_index -= 1
        if bracket_count == 1:
            res_tree.add_child(shapiro_to_tree(shapiro_str[str_index:str_start_index + 1],
                                               shapiro_index[bp_index:bp_start_index + 1], sequence))
            str_start_index = str_index - 1
            bp_start_index = bp_index - 1
        str_index -= 1
        bp_index -= 1
    return res_tree


class ShapiroTreeValue:
    def __init__(self, shapiro_str_name, shapiro_index, sequence):
        self.name = shapiro_str_name[0]
        self.preserve = False
        try:
            self.size = (int(shapiro_str_name[1:]) if shapiro_str_name[1:] != '' else 0)
        except ValueError:
            self.size = 0
            logging.error(
                "ShapiroTreeValue.__init__ error parsing ShapiroTreeValue({}, {}, {})".format(shapiro_str_name,
                                                                                              shapiro_index, sequence))
        if self.size == 0:
            self.index_list = []
            self.sequence = ''
        else:
            self.index_list = []
            for index in shapiro_index[1:len(shapiro_index) - 1].split(','):
                index = index.strip()
                if index.isdigit():
                    self.index_list.append(int(index))
                else:
                    logging.error("Error decyphering shapiro: name={}, index={}, sequence={}".format(shapiro_str_name,
                                                                                                     shapiro_index,
                                                                                                     sequence))
            self.index_list.sort()
            indexes = []
            last = None
            current = []
            for index in self.index_list:
                if last is None or index == last + 1:
                    current.append(index)
                else:
                    indexes.append(current)
                    current = [index]
                last = index
            indexes.append(current)
            self.sequence = ".".join(["".join([sequence[index] for index in group]) for group in indexes])

    def __str__(self):
        return "{}{}({})".format(self.name, self.size, self.sequence)

    '''
    def __init__(self, name, size, index_list):
        self.name = name
        self.size = size
        self.index_list = index_list
    '''


def get_tree(structure, sequence):
    shapiro = shapiro_generator.get_shapiro(structure)
    return shapiro_to_tree(shapiro.shapiro, shapiro.shapiro_indexes, sequence)


def align_trees(tree_source, tree_target,
                alignment_rules=tree_aligner.AlignmentRules(delete_func=delete_shapiro_func,
                                                            cmp_func=cmp_shapiro_tree_values,
                                                            merge_func=merge_shapiro_tree_values,
                                                            minmax_func=min)):
    return tree_aligner.align_trees(tree_source, tree_target, alignment_rules)


def align_shapiro(shapiro_source, sequence_source, shapiro_target, sequence_target,
                  alignment_rules=tree_aligner.AlignmentRules(delete_func=delete_shapiro_func,
                                                              cmp_func=cmp_shapiro_tree_values,
                                                              merge_func=merge_shapiro_tree_values,
                                                              minmax_func=min)):
    tree_source = shapiro_to_tree(sequence_source.shapiro, shapiro_source.shapiro_indexesm, sequence_source)
    tree_target = shapiro_to_tree(shapiro_target.shapiro, shapiro_target.shapiro_indexesm, sequence_target)
    return align_trees(tree_source, tree_target, alignment_rules)


def get_matching_indexes(aligned_tree):
    def break_consecutive(the_list):
        res_list = []
        for i in range(0, len(the_list)):
            if i == 0:
                res_list.append(the_list[i])
            elif the_list[i] > the_list[i-1] + 1:
                res_list.append(the_list[i])
        return res_list
    matching_index = []
    unmatching_index = []
    tree_stack = [aligned_tree]
    while tree_stack:
        top = tree_stack.pop()
        for child in top.children:
            tree_stack.append(child)
        if top.mode == 'M':
            start_list = break_consecutive(top.value.index_list)
            start_index = 0
            for source_part, target_part in top.value_align[::-1]:
                if source_part.replace('-', '') != '':
                    source_index = start_list[start_index]
                    for source_char, target_char in zip(source_part, target_part):
                        if source_char != '-':
                            if target_char != '-' and target_char != 'N':
                                if IUPAC.common_dna_code(source_char, target_char):
                                    matching_index.append(source_index + 1)
                                else:
                                    unmatching_index.append(source_index + 1)
                            source_index += 1
                    start_index += 1
    logging.debug("matching: {}\nunmatching: {}\naligned tree: {}".format(matching_index, unmatching_index,
                                                                          aligned_tree))
    return matching_index, unmatching_index


if __name__ == "__main__":
    '''
    logging.basicConfig(level=logging.DEBUG)
    '''
    '''
    print('Simple test 1')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..((((((.......))))....))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((..((.(((.......))))))..))..))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGCUCUCGUAUAGGCUCGGCCCC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNUNNNNNNUYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))

    print('Simple test 2')
    shapiro_one = shapiro_generator.get_shapiro("((.(((...)))...(((((.......))))....))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((..((.(((.......))))))..))..))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGCUCUCGUAUAGGCUCGGCCCC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNUNNNNNNUYNNNNNNNN')
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))

    print('Test alignment distance 28 / 10')
    shapiro_one = shapiro_generator.get_shapiro("((((((((.(.(((((...((((((..((((.....)))))).))))....))))).)...))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'GCGGGUUAUGUGCUGAGAUAGGCCCUUGCAGCGUUAUUGUGGAGUUUCCCAUUAGCUCCCCUGACCCGC')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))

    print('Test alignment distance 14 / 4')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..(.(.((((.((.....))...)))).).).((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'UCGGGAUAUGGUGGAAGGAUGAUGGCCAAGACCUUGCUCGCUGGGCUUCGGAUGCCCAGGUUGUUCCGA')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    print('Test alignment distance 1 / 0')
    shapiro_one = shapiro_generator.get_shapiro("((((((((..((.(((((.......))))).)).......((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'CUGGGGCCUUCGUGGGUUAUCUCUAAGCUCUCGUAUAUGAUCCGGUUCUACACGCCGGAACGGCCCCAG')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}\n".format(aligned_score, aligned_tree))
    print('Test perfect alignment')
    shapiro_one = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}".format(aligned_score, aligned_tree))
    '''
    print('Test presentation')
    shapiro_one = shapiro_generator.get_shapiro(".(((((((((.((.(((((............)))))))..........(((((((...))))))).)))))))))")
    shapiro_two = shapiro_generator.get_shapiro("((((((((...(.(((((.......))))).)........((((((.......))))))..))))))))")
    tree_one = shapiro_to_tree(shapiro_one.shapiro, shapiro_one.shapiro_indexes,
                               'GUUUCGAUGCUGCCUGCGCACUCUACUAUCAGCGCAGCUUUACAUCUCGAGUCAUGCAAUGGCUUUGCGUCGGGA')
    tree_two = shapiro_to_tree(shapiro_two.shapiro, shapiro_two.shapiro_indexes,
                               'NNNNNNNNUNNNNNNNNNNNNNNNNNNNNNNNNUNNNUNNNNNNNNNNNNNNNNNNNNNNYNNNNNNNN')
    print("Shapiro one: {}\nTree one: {}".format(shapiro_one.shapiro, tree_one))
    print("Shapiro two: {}\nTree two: {}".format(shapiro_two.shapiro, tree_two))
    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(delete_func=delete_shapiro_func, minmax_func=min,
                                    cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}".format(aligned_score, aligned_tree))

    aligned_tree, aligned_score = tree_aligner.align_trees(
        tree_one, tree_two,
        tree_aligner.AlignmentRules(
            delete_func=lambda t, is_target: delete_shapiro_func(t, is_target, 3),
            minmax_func=min, cmp_func=cmp_shapiro_tree_values, merge_func=merge_shapiro_tree_values))
    print("Aligned tree ({}): {}".format(aligned_score, aligned_tree))

